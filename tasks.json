{
    "tasks": [
        {
            "id": "1",
            "title": "Production Desktop Builds (Mac + Windows + Linux)",
            "status": "pending",
            "priority": "critical",
            "context": "electron-builder is installed (^24.9.1) and the build command exists in package.json, but there is NO platform-specific configuration. No code signing, no installer config, no auto-updater. Build resources exist at build/icon.png (512x512).",
            "created_at": "2026-02-12T12:01:00.000000",
            "subtasks": [
                {
                    "id": "1.1",
                    "title": "Create electron-builder.json with platform targets",
                    "status": "completed",
                    "context": "Mac: DMG + universal binary (Intel + Apple Silicon). Windows: NSIS installer. Linux: AppImage (optional, lower priority). Configure app metadata, file associations, protocol handler (anthracite://)."
                },
                {
                    "id": "1.2",
                    "title": "macOS code signing + notarization",
                    "status": "pending",
                    "context": "Requires Apple Developer account ($99/yr). Sign with Developer ID Application certificate. Notarize via notarytool. Without this, macOS will block the app with Gatekeeper."
                },
                {
                    "id": "1.3",
                    "title": "Windows Distribution: Publish to Microsoft Store",
                    "status": "pending",
                    "context": "Microsoft Store handles signing for free/cheap (~$19 once), avoiding the expensive EV cert ($400/yr). Requires packaging as MSIX. Users install via Store link or appinstaller."
                },
                {
                    "id": "1.4",
                    "title": "Configure electron-updater for auto-updates",
                    "status": "completed",
                    "context": "Use GitHub Releases as update server (free). electron-updater checks for new versions on app launch. Show update available notification in-app."
                },
                {
                    "id": "1.5",
                    "title": "Handle native module bundling (better-sqlite3)",
                    "status": "completed",
                    "context": "better-sqlite3 requires platform-specific .node binary. electron-rebuild is already configured (postinstall script). Verify it works in packaged builds on all platforms."
                },
                {
                    "id": "1.6",
                    "title": "Bundle Python backend with the Electron app",
                    "status": "completed",
                    "context": "Currently the Python backend (backend/) runs separately. For production: either bundle a Python runtime (PyInstaller/cx_Freeze the FastAPI server into a single binary) or require users to have Python installed. Bundling is strongly preferred for non-technical users. Alternative: rewrite backend in Node.js to eliminate Python dependency entirely."
                },
                {
                    "id": "1.7",
                    "title": "Test full install → launch → use → auto-update flow on Mac and Windows",
                    "status": "completed"
                }
            ]
        },
        {
            "id": "2",
            "title": "CI/CD Pipeline — Automated Builds & Releases",
            "status": "pending",
            "priority": "high",
            "context": "No GitHub Actions workflows exist for desktop builds. Website deploys via Vercel (already configured). Need automated multi-platform builds triggered on git tags.",
            "created_at": "2026-02-12T12:02:00.000000",
            "subtasks": [
                {
                    "id": "2.1",
                    "title": "Create .github/workflows/build.yml",
                    "status": "completed",
                    "context": "Matrix build: macos-latest (DMG), windows-latest (NSIS), ubuntu-latest (AppImage). Trigger on push to tags matching v*. Steps: checkout, setup Node, npm install, electron-rebuild, npm run build, upload artifacts."
                },
                {
                    "id": "2.2",
                    "title": "Store code signing secrets in GitHub Secrets",
                    "status": "pending",
                    "context": "Mac: APPLE_ID, APPLE_TEAM_ID, CSC_LINK (base64 .p12), CSC_KEY_PASSWORD. Windows: WIN_CSC_LINK, WIN_CSC_KEY_PASSWORD."
                },
                {
                    "id": "2.3",
                    "title": "Auto-publish to GitHub Releases on tag push",
                    "status": "completed",
                    "context": "Use electron-builder --publish always. Creates GitHub Release with platform artifacts attached."
                },
                {
                    "id": "2.4",
                    "title": "Add type-check and lint step before build",
                    "status": "completed"
                },
                {
                    "id": "2.5",
                    "title": "Cache node_modules and Electron binaries",
                    "status": "completed",
                    "context": "Use actions/cache for node_modules and ~/.cache/electron. Saves 2-3 min per build."
                }
            ]
        },
        {
            "id": "3",
            "title": "Website Waitlist Backend — Actually Save Signups",
            "status": "pending",
            "priority": "high",
            "context": "The signup form on anthracitebrowser.com (website/src/components/Signup.tsx) is purely cosmetic. It shows 'You're on the list' but saves nothing — no API call, no database, no email service. Need a real backend to collect and manage waitlist signups.",
            "created_at": "2026-02-12T12:03:00.000000",
            "subtasks": [
                {
                    "id": "3.1",
                    "title": "Choose and set up waitlist backend",
                    "status": "completed",
                    "context": "Options ranked by simplicity: (1) Vercel serverless function + Supabase table — free tier covers early stage, (2) Resend audience API — email-native, good for later sending launch emails, (3) Google Sheets API — quick and dirty. Recommended: Supabase for the table + Resend for confirmation emails."
                },
                {
                    "id": "3.2",
                    "title": "Create API endpoint for signup submission",
                    "status": "completed",
                    "context": "POST /api/signup accepting { name, email, role }. Validate email format. Check for duplicates. Return success/error."
                },
                {
                    "id": "3.3",
                    "title": "Connect Signup.tsx to the real API",
                    "status": "completed",
                    "context": "Replace the cosmetic setSubmitted(true) in handleSubmit with an actual fetch() to the API. Handle loading state, errors, duplicate emails gracefully."
                },
                {
                    "id": "3.4",
                    "title": "Send confirmation email on signup (optional)",
                    "status": "pending",
                    "context": "Use Resend or similar. Simple email: 'Thanks for signing up for Anthracite. We'll notify you when it's ready.'"
                },
                {
                    "id": "3.5",
                    "title": "Create admin view or export for signups",
                    "status": "pending",
                    "context": "At minimum: ability to export CSV of all signups. Supabase dashboard gives this for free."
                }
            ]
        },
        {
            "id": "4",
            "title": "Replace Custom CDP Agent with browser-use + Claude Sonnet 4.6",
            "status": "pending",
            "priority": "critical",
            "context": "BACKGROUND: Anthracite currently has a hand-rolled CDP agent (backend/cdp_agent.py) that was built to replace browser-use. It uses Accessibility.getFullAXTree only, has no reflection, no real memory, and hallucinates specific data (prices, names) it cannot see. We have tried patching it extensively — input float-to-top, autocomplete detection, done() guards, planner phase, model escalation — but it remains unreliable on real-world tasks like 'find cheapest hotel in Brisbane CBD 22 Feb' because it fundamentally cannot read prices from the page (prices are short static DOM text, not AX-interactive elements) and gpt-4o gives up and invents data.\n\nWHY BROWSER-USE NOW: browser-use has ABANDONED Playwright and migrated to raw CDP (their own cdp-use library, 2025). This makes it architecturally identical to our custom agent at the transport level. browser-use's agent is significantly more capable: it merges DOM + AX tree + Snapshot tree into EnhancedDOMTreeNode structures (preserving which price belongs to which hotel card — the exact structural context we are missing); it has explicit per-step memory (AgentOutput.memory field carries key facts between steps); it has a reflection/evaluation step (was the action effective?); an ActionLoopDetector that injects nudge messages on repeated patterns; and message compaction that summarises history instead of dropping it. All of this has been tuned on real web tasks for over a year.\n\nWHY CLAUDE SONNET 4.6: Claude Sonnet 4.6 scores 72.5% on computer use benchmarks, significantly better than GPT-4o on web interaction tasks. browser-use natively supports Anthropic via langchain_anthropic. Cost: $3/M input + $15/M output vs GPT-4o at $2.50/M + $10/M — Claude is ~30-40% more expensive per task but the accuracy gain justifies it. For a typical 10-step agent task (~20k input tokens, ~2k output tokens) the cost difference is ~$0.02/task.\n\nARCHITECTURE TO PRESERVE: The Electron app has two surfaces per tab — an off-screen BrowserView (y=-10000, default session) and an on-screen <webview> (persist:anthracite session). Agent tabs connect to the webview's CDP target, NOT the BrowserView. The webview CDP target is found by querying http://127.0.0.1:9222/json, filtering for type='webview', and excluding about: URLs (which are the BrowserView marker). This means the agent controls what the user actually sees. This architecture MUST be preserved — the browser-use agent must connect to the same webview CDP target.\n\nWHAT TO KEEP FROM CURRENT BACKEND: (1) backend/classifier.py — regex-first intent classifier that routes 'go to youtube.com' to fast_navigate (no agent needed) and everything else to the agent. Keep this entirely. (2) backend/server.py /agent/stream SSE endpoint — the streaming architecture (SSE queue, step_callback, agent_control stop/pause/resume) should be kept. Only the agent call inside changes. (3) The fast_navigate path in server.py — when classifier returns fast_navigate, we tell the frontend to navigate via IPC (no agent needed). Keep this.\n\nWHAT TO REPLACE: backend/cdp_agent.py — the entire file. Replace with a thin adapter that: (a) resolves the webview's WebSocket URL using the existing _get_ws_url logic, (b) creates a browser-use BrowserSession connected to that WebSocket URL, (c) creates a browser-use Agent with Claude Sonnet 4.6 as the LLM, (d) runs the agent with step callbacks wired to the SSE queue.",
            "created_at": "2026-02-20T00:00:00.000000",
            "subtasks": [
                {
                    "id": "4.1",
                    "title": "Install browser-use and Anthropic SDK dependencies",
                    "status": "pending",
                    "context": "Add to backend/requirements.txt: browser-use (latest, for raw CDP agent), langchain-anthropic (for Claude Sonnet 4.6 LLM). Remove or keep langchain-openai as fallback. Verify: pip install browser-use langchain-anthropic. Check that browser-use's version already uses cdp-use (not Playwright) — this happened in late 2025, confirm from browser-use changelog/releases. If browser-use still uses Playwright internally, use the latest version that includes the CDP migration."
                },
                {
                    "id": "4.2",
                    "title": "Resolve webview CDP WebSocket URL for browser-use BrowserSession",
                    "status": "pending",
                    "context": "Current logic in cdp_agent.py _get_ws_url(): fetch http://127.0.0.1:9222/json, find the target whose id matches target_id passed from the frontend. This target_id is the webview's CDP target ID, sent via IPC when an agent task starts (see src/main/main.ts and src/renderer/components/CommandBar.tsx). browser-use BrowserSession accepts a cdp_url or websocket_url parameter — pass the resolved WebSocket debugger URL directly. Do NOT pass just http://127.0.0.1:9222 as the cdp_url because that connects to the whole browser, not the specific tab. The webSocketDebuggerUrl from /json looks like: ws://127.0.0.1:9222/devtools/page/<target_id>."
                },
                {
                    "id": "4.3",
                    "title": "Create backend/cdp_agent.py adapter wrapping browser-use Agent",
                    "status": "pending",
                    "context": "Replace the current cdp_agent.py entirely. The public interface must remain compatible with server.py: async def run_agent_task_streaming(instruction, target_id, api_key=None, step_callback=None, should_stop=None) -> str. Internally: (1) resolve webview WebSocket URL via _get_ws_url(target_id), (2) create BrowserSession(websocket_url=ws_url) — do NOT let browser-use launch a new browser, only connect to the existing webview, (3) create ChatAnthropic(model='claude-sonnet-4-6', api_key=anthropic_key) as the LLM, (4) create Agent(task=instruction, llm=llm, browser_session=session), (5) run agent with on_step_end callback that calls step_callback and checks should_stop, (6) return agent history final_result(). The step_callback signature expected by server.py is: async def step_callback(step_num, action, args, result). Map browser-use's step data to this format."
                },
                {
                    "id": "4.4",
                    "title": "Wire browser-use step callbacks to SSE streaming in server.py",
                    "status": "pending",
                    "context": "server.py /agent/stream already has SSE infrastructure: an asyncio.Queue, a step_callback that pushes {type: 'step', step, next_goal, actions} events, and a run_agent() background task. The step_callback in server.py currently expects (step_num, action, args, result). browser-use Agent has on_step_end(agent_output, step_number) callback — extract the action name and args from agent_output.action and map to the expected format. Also wire the should_stop check: on each step, check agent_control.should_stop() and if true, raise InterruptedError inside the callback to abort the agent. The 'done' event should fire when agent.run() completes with the final result string."
                },
                {
                    "id": "4.5",
                    "title": "Handle API key routing: Anthropic key for executor, OpenAI key for planner (optional)",
                    "status": "pending",
                    "context": "The current system reads OPENAI_API_KEY from .env or from the frontend request (TaskRequest.api_key). We need to add ANTHROPIC_API_KEY support. server.py TaskRequest model has api_key field — extend to support anthropic_api_key or detect which key is provided. The frontend Settings page (src/renderer/components/SettingsPage.tsx) currently has an OpenAI key field — add an Anthropic key field. For users who only have an OpenAI key, fall back to gpt-4o as the executor (keep this as a graceful fallback, not an error). Priority: Anthropic key → Claude Sonnet 4.6. OpenAI key only → gpt-4o. Neither → error with clear message."
                },
                {
                    "id": "4.6",
                    "title": "Preserve classifier + fast_navigate path exactly as-is",
                    "status": "pending",
                    "context": "backend/classifier.py must not be changed. It is regex-first, defaults to 'complex' on no match (no LLM fallback — intentional asymmetric risk). The fast_navigate path in server.py /agent/stream must remain: when classifier returns fast_navigate, yield {type: 'fast_action', action: 'navigate', url: url} which tells the frontend to navigate via IPC (tab URL bar updates, history records). This path has zero LLM calls and is near-instant. The agent is only invoked when classifier returns 'complex'. This two-tier approach is the product's speed advantage — keep it intact."
                },
                {
                    "id": "4.7",
                    "title": "Verify browser-use does not create a new browser session or overwrite webview cookies",
                    "status": "pending",
                    "context": "Critical: the webview uses 'persist:anthracite' Electron session partition. This means the user's cookies, login sessions (Google, etc.) are in this partition. When browser-use connects via CDP to the webview's WebSocket URL, it must NOT reset the page, clear cookies, or navigate away before the task starts. Verify: BrowserSession in connect-to-existing-browser mode should not call Page.resetNavigationHistory, Storage.clearDataForOrigin, or similar. If browser-use does any of these on connect, we need to disable them. Test: user is logged into Google in a tab, run agent task on that tab, verify Google session is still active after agent finishes."
                },
                {
                    "id": "4.8",
                    "title": "Add Anthropic key field to Settings UI",
                    "status": "pending",
                    "context": "src/renderer/components/SettingsPage.tsx currently has one API key field (OpenAI). Add a second field for Anthropic API key. Same UX: password input, test button that hits a new /test-api-key-anthropic endpoint, stored via electron.settings.set('anthropicApiKey', ...) using safeStorage. The frontend CommandBar should send the Anthropic key alongside the instruction when starting an agent task. Update the TaskRequest model in server.py and the IPC message in preload.ts/main.ts accordingly."
                },
                {
                    "id": "4.9",
                    "title": "Integration test: real-world tasks that previously failed",
                    "status": "pending",
                    "context": "Test the following tasks that failed with the custom agent and must pass with browser-use + Claude: (1) 'find cheapest hotel in Brisbane CBD 22 Feb' — agent must go to booking.com, set the destination, set the date using the calendar picker, search, sort by price, and return the actual cheapest hotel name and price visible on the page. (2) 'find cheapest flight from Sydney to Brisbane' — agent must go to google.com/flights, fill origin/destination, handle autocomplete suggestions, set the date, and return flight options with prices. (3) 'play punjabi music on YouTube' — agent must navigate to youtube.com, search for punjabi music, and click a video to start playing it. (4) 'what is the weather in Tokyo' — fast_navigate path should handle this (google search), no agent needed. For each test, check terminal logs to verify: correct site visited, correct fields filled, no hallucinated data in final result."
                }
            ]
        },
        {
            "id": "5",
            "title": "Google/OAuth Account Linking — Agent Auth",
            "status": "pending",
            "priority": "critical",
            "context": "Users need to link accounts (Google, Microsoft, etc.) so the AI agent can act as them — log into Gmail, book flights on their airline account, manage their calendar. Currently the agent has NO auth context and cannot access any logged-in services. This is NOT traditional OAuth (we don't need API tokens) — the agent needs actual browser session cookies so it can navigate sites as the user.",
            "created_at": "2026-02-12T12:05:00.000000",
            "subtasks": [
                {
                    "id": "5.1",
                    "title": "Design the auth persistence architecture",
                    "status": "pending",
                    "context": "When user logs into Google in a normal Anthracite tab, capture and persist the session cookies for google.com. Store them so they survive app restarts. Electron's session.defaultSession.cookies API can get/set cookies. The agent's CDP-connected BrowserView needs to share these cookies."
                },
                {
                    "id": "5.2",
                    "title": "Implement persistent cookie/session storage",
                    "status": "pending",
                    "context": "Electron sessions are ephemeral by default (persist: prefix helps but needs explicit setup). Use session.defaultSession.cookies.get/set to save critical auth cookies. Encrypt stored cookies at rest using Electron's safeStorage API."
                },
                {
                    "id": "5.3",
                    "title": "Share session state between user browsing and agent BrowserView",
                    "status": "pending",
                    "context": "Currently the agent uses a separate BrowserView (off-screen, connected via CDP). It needs the same session cookies as the user's normal browsing session. Either use the same Electron session partition, or copy cookies before agent task starts."
                },
                {
                    "id": "5.4",
                    "title": "Add 'Connected Accounts' section in Settings",
                    "status": "pending",
                    "context": "Show which services the agent has access to (based on stored sessions). E.g., 'Google — signed in as user@gmail.com', 'GitHub — signed in'. Allow user to disconnect (clear cookies for that domain)."
                },
                {
                    "id": "5.5",
                    "title": "Handle session expiry detection and re-auth prompts",
                    "status": "pending",
                    "context": "Sessions expire. When the agent tries to act on a site and gets redirected to login, detect this and prompt the user: 'Your Google session has expired. Please sign in again.' Pause agent, let user sign in, then resume."
                },
                {
                    "id": "5.6",
                    "title": "Security: encrypt stored session data, never send externally",
                    "status": "pending",
                    "context": "Session cookies are extremely sensitive (they ARE the user's identity). Encrypt at rest using Electron safeStorage. Never transmit to any server. Never include in error reports. Clear on 'Sign Out' of Anthracite account."
                }
            ]
        },
        {
            "id": "6",
            "title": "Multi-Model Support & API Key Management UI",
            "status": "pending",
            "priority": "high",
            "context": "After task 4, Anthracite uses Claude Sonnet 4.6 (Anthropic) as the primary executor model and optionally gpt-4o (OpenAI) as fallback. Users need to configure their own API keys. The Settings page currently has only an OpenAI key field — Anthropic key field is added as part of task 4.8. This task covers the full multi-model UX: model selector in CommandBar, secure key storage, and support for additional providers.",
            "created_at": "2026-02-12T12:06:00.000000",
            "subtasks": [
                {
                    "id": "6.1",
                    "title": "Complete API Key settings page (Anthropic + OpenAI)",
                    "status": "pending",
                    "context": "Anthropic key field is added in task 4.8. This subtask: add Google AI (Gemini) key field as a third option. All keys: password input, inline test button, stored via safeStorage. Show which keys are currently active. Clear visual hierarchy: Anthropic (recommended, Claude Sonnet 4.6) > OpenAI (fallback, gpt-4o) > Google (future)."
                },
                {
                    "id": "6.2",
                    "title": "Make CommandBar model selector functional",
                    "status": "pending",
                    "context": "The model selector button in CommandBar.tsx currently shows static text. Make it a dropdown: available options depend on which keys the user has set. Default: Claude Sonnet 4.6 if Anthropic key is set, else gpt-4o if OpenAI key is set. Persist last-used model. Send chosen model to backend with each agent task request."
                },
                {
                    "id": "6.3",
                    "title": "Support local models via Ollama",
                    "status": "pending",
                    "context": "For privacy-conscious users: detect if Ollama is running locally (http://localhost:11434), list available models, route agent calls through Ollama. No API key needed. Lower quality but free and private. browser-use supports Ollama via langchain-community OllamaLLM."
                }
            ]
        },
        {
            "id": "7",
            "title": "User Authentication System",
            "status": "pending",
            "priority": "high",
            "context": "Currently zero auth exists in the desktop app. Everything is local. Need user accounts for: cloud sync, subscription management, cross-device continuity. This is a prerequisite for tasks 8 (sync) and 9 (payments).",
            "created_at": "2026-02-12T12:07:00.000000",
            "subtasks": [
                {
                    "id": "7.1",
                    "title": "Choose auth provider",
                    "status": "pending",
                    "context": "Options: Clerk (best DX, generous free tier, handles OAuth flows), Supabase Auth (if already using Supabase for waitlist), Firebase Auth, or custom. Clerk recommended for speed and Electron compatibility."
                },
                {
                    "id": "7.2",
                    "title": "Implement sign-up / sign-in flow in Electron",
                    "status": "pending",
                    "context": "OAuth popup window (BrowserWindow) for Google/GitHub sign-in. Store auth tokens securely via Electron safeStorage. Show auth state in sidebar footer or settings."
                },
                {
                    "id": "7.3",
                    "title": "Support: email/password, Google OAuth, GitHub OAuth, Apple Sign-In",
                    "status": "pending"
                },
                {
                    "id": "7.4",
                    "title": "Add user profile section in Settings",
                    "status": "pending",
                    "context": "Show: avatar, name, email, plan tier, sign-out button. Link to subscription management."
                },
                {
                    "id": "7.5",
                    "title": "Handle offline mode gracefully",
                    "status": "pending",
                    "context": "App must work fully without auth — just without sync/cloud/subscription features. Never block the browser because of auth issues."
                }
            ]
        },
        {
            "id": "8",
            "title": "Cloud Sync — Realms, Docks, History, Settings",
            "status": "pending",
            "priority": "medium",
            "context": "All user data is currently local only. Realms/Docks in anthracite-realms.json, history in SQLite (history.db), settings in settings.json. Authenticated users should be able to sync across devices. Depends on task 7 (user auth).",
            "created_at": "2026-02-12T12:08:00.000000",
            "subtasks": [
                {
                    "id": "8.1",
                    "title": "Design sync architecture",
                    "status": "pending",
                    "context": "Options: (1) CRDTs for conflict-free merging (complex but robust), (2) Last-write-wins per entity (simpler, occasional data loss), (3) Manual merge on conflict (user decides). Start with last-write-wins for settings, CRDTs for realms/docks. Backend: Supabase Postgres + realtime subscriptions."
                },
                {
                    "id": "8.2",
                    "title": "Implement settings sync (simplest — start here)",
                    "status": "pending",
                    "context": "Settings are a single JSON blob. On change: upload to cloud. On login from new device: merge with local (cloud wins for most fields). Files: src/main/settings.ts."
                },
                {
                    "id": "8.3",
                    "title": "Implement realms & docks sync",
                    "status": "pending",
                    "context": "More complex — realms contain docks which contain tabs. Need entity-level sync, not whole-file replacement. Files: src/main/store.ts."
                },
                {
                    "id": "8.4",
                    "title": "Implement history sync",
                    "status": "pending",
                    "context": "SQLite history.db. Sync recent entries (last 30 days). Don't sync entire history — too large. Files: src/main/history.ts."
                },
                {
                    "id": "8.5",
                    "title": "Handle offline → online reconciliation",
                    "status": "pending",
                    "context": "Queue changes made while offline. Sync when connection restored. Handle conflicts."
                }
            ]
        },
        {
            "id": "9",
            "title": "Subscription & Payment System",
            "status": "pending",
            "priority": "high",
            "context": "Monetization layer. Business model: Free tier (bring your own API key, full browser features) + Pro tier (monthly subscription with agent credits — no API key needed, Anthracite proxies LLM calls). The agent must be significantly better than open-source alternatives for people to pay. Depends on tasks 4 (agent) and 7 (user auth).",
            "created_at": "2026-02-12T12:09:00.000000",
            "subtasks": [
                {
                    "id": "9.1",
                    "title": "Integrate payment provider",
                    "status": "pending",
                    "context": "Options: Stripe (industry standard, complex tax handling), Paddle (handles international tax/VAT automatically, simpler for solo dev). Paddle recommended for simpler setup. LemonSqueezy is another option."
                },
                {
                    "id": "9.2",
                    "title": "Design pricing tiers",
                    "status": "pending",
                    "context": "Free: BYOK (bring your own API key), all browser features, local agent. Pro ($X/month): N agent credits (each credit = 1 agent task), Anthracite's API proxy (no key needed), priority support, cloud sync. Team: future (shared realms, admin controls)."
                },
                {
                    "id": "9.3",
                    "title": "Build API proxy server for paid users",
                    "status": "pending",
                    "context": "Paid users' agent calls route through Anthracite's backend using our API keys. This backend meters usage, enforces rate limits, and bills per credit. Tech: serverless functions or a lightweight API on Railway/Fly.io. Keys stored server-side, never sent to client."
                },
                {
                    "id": "9.4",
                    "title": "Implement credit/usage tracking",
                    "status": "pending",
                    "context": "Track: number of agent tasks run, tokens consumed, cost per task. Show usage in Settings: 'You've used 47 of 200 credits this month.' Warn at 80% and 100% usage."
                },
                {
                    "id": "9.5",
                    "title": "Add subscription management in Settings",
                    "status": "pending",
                    "context": "Show: current plan, usage bar, billing cycle, upgrade/downgrade button (opens Stripe/Paddle portal), payment history."
                },
                {
                    "id": "9.6",
                    "title": "Handle edge cases: payment failures, grace periods, downgrades",
                    "status": "pending",
                    "context": "On payment failure: 3-day grace period, then downgrade to free. On downgrade: keep all data, just disable proxy access. Never delete user data because of billing."
                },
                {
                    "id": "9.7",
                    "title": "In-app upgrade prompts (tasteful, not aggressive)",
                    "status": "pending",
                    "context": "When free user without API key tries to run agent: show a subtle prompt explaining they need either their own key or a Pro subscription. Never block normal browsing. Never nag."
                }
            ]
        },
        {
            "id": "10",
            "title": "Agent Task History & Saved Workflows",
            "status": "pending",
            "priority": "medium",
            "context": "The agent has no memory between tasks. It should remember past interactions, learn user preferences, and allow saving repeatable workflows. This makes the agent feel intelligent rather than stateless.",
            "created_at": "2026-02-12T12:10:00.000000",
            "subtasks": [
                {
                    "id": "10.1",
                    "title": "Store agent task history",
                    "status": "pending",
                    "context": "For each agent run, save: user instruction, classified intent, steps taken (actions + screenshots), success/failure, duration, model used, tokens consumed. Store in SQLite alongside browsing history."
                },
                {
                    "id": "10.2",
                    "title": "Add 'Task History' view in the UI",
                    "status": "pending",
                    "context": "New section accessible from sidebar or settings. Show past agent runs with step-by-step replay. Click a past task to see what the agent did. Option to re-run a task."
                },
                {
                    "id": "10.3",
                    "title": "Implement agent context memory",
                    "status": "pending",
                    "context": "Agent should know: user's name, frequently visited sites, preferred services (Gmail vs Outlook, Google Flights vs Kayak), past task patterns. Build a lightweight user profile the agent references on each run."
                },
                {
                    "id": "10.4",
                    "title": "Saved workflows — repeatable multi-step agent tasks",
                    "status": "pending",
                    "context": "Allow users to save an agent task as a 'workflow' (e.g., 'Check my email and summarize unread', 'Search for flights to X on Y date'). Show saved workflows in CommandBar or sidebar for one-click re-run."
                }
            ]
        },
        {
            "id": "11",
            "title": "Agent Reliability — Edge Cases & Failure Handling",
            "status": "pending",
            "priority": "high",
            "context": "Common scenarios where the agent breaks or gets stuck. browser-use handles many of these better than our custom agent, but some still need explicit handling. Fixing these is critical for user trust and the paid tier value proposition.",
            "created_at": "2026-02-12T12:11:00.000000",
            "subtasks": [
                {
                    "id": "11.1",
                    "title": "CAPTCHA handling — detect and defer to user",
                    "status": "pending",
                    "context": "When agent encounters a CAPTCHA: pause agent, show the page to the user, prompt them to solve it, then resume agent automatically after CAPTCHA is cleared."
                },
                {
                    "id": "11.2",
                    "title": "Handle popups, cookie banners, overlay modals",
                    "status": "pending",
                    "context": "These block element interaction. Agent should detect common patterns (cookie consent, newsletter popups, paywall modals) and dismiss them before attempting the actual task."
                },
                {
                    "id": "11.3",
                    "title": "Handle iframes and shadow DOM",
                    "status": "pending",
                    "context": "Many sites use iframes (e.g., payment forms, embedded content) and shadow DOM (web components). browser-use has cross-origin iframe support built in (added when they moved to raw CDP)."
                },
                {
                    "id": "11.4",
                    "title": "Handle file downloads and uploads",
                    "status": "pending",
                    "context": "Agent may trigger downloads (PDFs, CSVs) or need to upload files (forms, attachments). Integrate with Electron's download manager and file dialog."
                },
                {
                    "id": "11.5",
                    "title": "Improve form filling — dropdowns, date pickers, multi-step forms",
                    "status": "pending",
                    "context": "browser-use's EnhancedDOMTreeNode gives structural context (which field belongs to which form) and screenshot fallback for visual elements. Date pickers and custom dropdowns should be handled better than with our flat AX tree approach."
                },
                {
                    "id": "11.6",
                    "title": "Timeout handling — don't spin forever",
                    "status": "pending",
                    "context": "Add per-step timeouts (30s default) and per-task timeouts (5min default). If stuck, try alternative approach or ask user for help. Never leave agent running silently."
                },
                {
                    "id": "11.7",
                    "title": "Handle new tab/window creation during agent tasks",
                    "status": "pending",
                    "context": "Some sites open links in new tabs. Agent needs to follow into the new tab, complete the action, and return. Currently handled partially in main.ts setWindowOpenHandler but not integrated with agent flow."
                }
            ]
        },
        {
            "id": "12",
            "title": "Error Reporting & Crash Recovery",
            "status": "pending",
            "priority": "medium",
            "context": "No error reporting or crash recovery exists. No visibility into what breaks for users in the wild.",
            "created_at": "2026-02-12T12:12:00.000000",
            "subtasks": [
                {
                    "id": "12.1",
                    "title": "Integrate Sentry for Electron main + renderer crashes",
                    "status": "pending"
                },
                {
                    "id": "12.2",
                    "title": "Add Python backend error reporting",
                    "status": "pending",
                    "context": "Catch uncaught exceptions in agent runs. Report to Sentry with task context (instruction, model, step count)."
                },
                {
                    "id": "12.3",
                    "title": "Implement crash recovery — restore tabs/realms on restart",
                    "status": "pending",
                    "context": "On app crash, save current state. On next launch, detect crash and offer to restore previous session."
                },
                {
                    "id": "12.4",
                    "title": "Add 'Report a Problem' in help menu / settings",
                    "status": "pending"
                }
            ]
        },
        {
            "id": "13",
            "title": "Chrome Data Import & First-Run Experience",
            "status": "pending",
            "priority": "medium",
            "context": "Users switching from Chrome/Brave/Edge need to import data. Critical for reducing switching friction. No import functionality exists.",
            "created_at": "2026-02-12T12:13:00.000000",
            "subtasks": [
                {
                    "id": "13.1",
                    "title": "Import bookmarks → map to Anthracite Realms/Docks",
                    "status": "pending",
                    "context": "Chrome bookmarks are folders. Map top-level folders to Realms, sub-folders to Docks, bookmarks to pinned tabs or dock items."
                },
                {
                    "id": "13.2",
                    "title": "Import browsing history into SQLite",
                    "status": "pending"
                },
                {
                    "id": "13.3",
                    "title": "Import saved passwords (optional, offer to skip)",
                    "status": "pending",
                    "context": "Sensitive. Store in OS keychain if imported. Many users may prefer to skip and use a password manager."
                },
                {
                    "id": "13.4",
                    "title": "First-run import wizard on initial launch",
                    "status": "pending",
                    "context": "Detect installed browsers, offer to import. Clean, minimal UI matching Anthracite aesthetic. Steps: Welcome → Import → API Key Setup → Done."
                },
                {
                    "id": "13.5",
                    "title": "Support Chrome, Brave, Edge, Firefox, Safari",
                    "status": "pending"
                }
            ]
        },
        {
            "id": "14",
            "title": "Keyboard Shortcuts & Command Palette",
            "status": "pending",
            "priority": "medium",
            "context": "Some shortcuts exist (Cmd+R, Cmd+Shift+K for realm search) but there's no command palette and no customization.",
            "created_at": "2026-02-12T12:14:00.000000",
            "subtasks": [
                {
                    "id": "14.1",
                    "title": "Add Cmd+K / Ctrl+K command palette for all browser actions",
                    "status": "pending"
                },
                {
                    "id": "14.2",
                    "title": "Add tab quick-switch with fuzzy search",
                    "status": "pending"
                },
                {
                    "id": "14.3",
                    "title": "Document and audit all existing shortcuts",
                    "status": "pending"
                },
                {
                    "id": "14.4",
                    "title": "Add customizable keybindings in settings",
                    "status": "pending"
                }
            ]
        },
        {
            "id": "15",
            "title": "Testing Infrastructure",
            "status": "pending",
            "priority": "medium",
            "context": "Zero tests exist in the project. No test framework configured. Need at minimum unit tests for core logic and E2E tests for critical user flows.",
            "created_at": "2026-02-12T12:15:00.000000",
            "subtasks": [
                {
                    "id": "15.1",
                    "title": "Set up Vitest for unit tests",
                    "status": "pending"
                },
                {
                    "id": "15.2",
                    "title": "Write unit tests for core modules: history.ts, store.ts, settings.ts, classifier.py",
                    "status": "pending"
                },
                {
                    "id": "15.3",
                    "title": "Set up Playwright for Electron E2E tests",
                    "status": "pending"
                },
                {
                    "id": "15.4",
                    "title": "Write E2E tests: app launch, tab management, navigation, agent task execution",
                    "status": "pending"
                },
                {
                    "id": "15.5",
                    "title": "Run tests in CI (GitHub Actions)",
                    "status": "pending"
                }
            ]
        },
        {
            "id": "16",
            "title": "Mobile Browser (Later Stage — iOS & Android)",
            "status": "pending",
            "priority": "low",
            "context": "Separate project from the Electron desktop app. Do NOT start until desktop is stable and monetized. Major architectural decisions needed — mobile can't run Python locally, so agent tasks must go through a cloud backend. iOS requires WebKit (Apple policy). Android allows custom engines.",
            "created_at": "2026-02-12T12:16:00.000000",
            "subtasks": [
                {
                    "id": "16.1",
                    "title": "Research & architecture planning",
                    "status": "pending",
                    "context": "Options: React Native + WebView, native Swift (iOS) + Kotlin (Android), or a hybrid. Determine which features carry over. Design mobile-specific UI (bottom nav, gesture-based tab switching). Plan cloud-based agent infrastructure."
                },
                {
                    "id": "16.2",
                    "title": "Build iOS app",
                    "status": "pending",
                    "context": "Must use WKWebView (Apple policy). Swift recommended for best performance and App Store compliance."
                },
                {
                    "id": "16.3",
                    "title": "Build Android app",
                    "status": "pending",
                    "context": "Can use custom Chromium or standard WebView. Kotlin recommended."
                },
                {
                    "id": "16.4",
                    "title": "Cloud-based agent backend for mobile",
                    "status": "pending",
                    "context": "Mobile devices can't run the Python agent locally. Build a cloud API that runs browser-use tasks on server-side browsers. This is also the infrastructure needed for the paid proxy tier (task 9)."
                },
                {
                    "id": "16.5",
                    "title": "App Store & Play Store submission",
                    "status": "pending"
                }
            ]
        },
        {
            "id": "17",
            "title": "Upgrade Application Menu & Native Features",
            "status": "pending",
            "priority": "medium",
            "context": "Expand the native Electron menu to include standard browser features (File, Edit, View, History, Window, Help). Add keyboard shortcuts for common actions.",
            "created_at": "2026-02-13T08:10:00.000000",
            "subtasks": [
                {
                    "id": "17.1",
                    "title": "Implement 'File' menu (New Tab, New Window, Save Page As, Print)",
                    "status": "pending"
                },
                {
                    "id": "17.2",
                    "title": "Implement 'Edit' menu (Undo, Redo, Cut, Copy, Paste, Select All, Find in Page)",
                    "status": "pending"
                },
                {
                    "id": "17.3",
                    "title": "Implement 'View' menu (Reload, Force Reload, Toggle DevTools, Actual Size, Zoom In, Zoom Out, Toggle Full Screen)",
                    "status": "pending"
                },
                {
                    "id": "17.4",
                    "title": "Implement 'History' menu (Back, Forward, Home, Show Full History, Clear Browsing Data)",
                    "status": "pending"
                },
                {
                    "id": "17.5",
                    "title": "Implement 'Window' menu (Minimize, Zoom, Tile Window to Left/Right, Bring All to Front)",
                    "status": "pending"
                },
                {
                    "id": "17.6",
                    "title": "Implement 'Help' menu (Report Issue, Keyboard Shortcuts, About Anthracite)",
                    "status": "pending"
                }
            ]
        }
    ]
}
